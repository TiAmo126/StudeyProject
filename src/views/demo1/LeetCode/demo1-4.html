<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2020/03/32 （数组tag）中等难度</title>
</head>

<body>

<script type="text/javascript">
  /**
   * 思想汇总：
   * 1.找规律；
   *
   * */

  /**
   * 11. 盛最多水的容器
   *
   *收获：
   * */
// 1.双指针
  function maxArea(height) {
    // 定位两个指针在数组的左右方
    let left = 0;
    let right = height.length - 1;
    let result = 0;
    while (left < right) {
      // 容器的宽就是两数坐标之差
      let x = right - left;
      // 容器的高就是两数之间较小的数
      let y = height[left] <= height[right] ? height[left] : height[right];
      result = (x * y) >= result ? (x * y) : result;
      // 那边的数较小我们就移动那边的数，去寻找是否有更大值
      // 因为容器的高取决于两数间较小值，我们可以牺牲宽度，寻求更大高度
      if (height[right] > height[left]) {
        left++
      } else {
        right--
      }
    }
    return result;
  }

  /**
   * 15. 三数之和
   *
   *收获：
   * */
  // 先对数组进行排序，选定一个数，剩下两个符合条件的数用双指针法来寻找，记得重复数字跳过以免出现重复数组
  function threeSum(nums) {
    let result = [];
    if (nums.length <= 3) {
      return result
    }
    nums.sort((a, b) => {
      return a - b
    });
    if (nums[0] > 0) {
      return result
    }
    for (let i = 0; i < nums.length; i++) {
      // 因为是排过序的，如果第一个数大于0，说明没有负数，既没有满足条件的数
      if (i > 0 && nums[i] === nums[i - 1]) {
        continue
      }
      // 定义较小指针为定数右边一位的数，大指针为数组末尾既最大数
      let left = i + 1;
      let right = nums.length - 1;
      // 进行双指针比较，三数之和如果小于0，移动较小指针；三数之和大于0，移动较大指针
      // 三数之和等于0，需要去重操作，既如果较小指针的下一个数跟它相等，left++,跳过该数
      // 如果较大指针的上一个数跟它相等，right--,跳过该数
      while (left < right) {
        let sum = nums[i] + nums[left] + nums[right];
        if (sum === 0) {
          result.push([nums[i], nums[left], nums[right]]);
          while (left < right && nums[left] === nums[left + 1]) {
            left++;
          }
          while (left < right && nums[right] === nums[right - 1]) {
            right--;
          }
          left++;
          right--;
        } else if (sum < 0) {
          left++;
        } else if (sum > 0) {
          right--;
        }
      }
    }
    return result
  }

  /**
   * 16. 最接近的三数之和
   *
   *收获：eval可计算字符串表达式，利用join拆分数组元素为"x+y"的形式，达到数组求和的效果
   * */
  // 1.双指针
  function threeSumClosest(nums, target) {
    nums.sort((a, b) => {
      return a - b;
    });
    let result = nums[0] + nums[1] + nums[2];
    for (let i = 0; i < nums.length; i++) {
      let left = i + 1;
      let right = nums.length - 1;
      while (left < right) {
        let sum = nums[i] + nums[left] + nums[right];
        // 比较出更接近目标值的和
        if (Math.abs(target - sum) < Math.abs(target - result)) {
          result = sum;
        }
        // 如果和小于目标数，说明小指针可以再大点说不定会有好的效果，反正在上面我们有一重判断能告诉我们究竟哪个值更接近目标数
        if (sum < target) {
          left++
        } else if (sum > target) {
          right--
        } else {
          return sum
        }
      }
    }
    return result
  }

  /**
   * 31. 下一个排列
   *
   *收获：不算完全理解
   * */

  function nextPermutation(nums) {
    let start = 0;
    let end = nums.length - 1;

    let left = end;
    let right = end;
    // 从后往前遍历，找到第一个降序集合，例子[1,3,5,7,6,4]，这里的[5,7]就是一个降序段
    for (; left > 0; left--) {
      if (nums[left] > nums[left - 1]) {
        break;
      }
    }

    // 继续从后往前找，找到降序集合中靠右边的数字为止，找一个比降序集合中靠左边的数字稍大一点的数
    if (left > 0) {
      for (; right >= left; right--) {
        if (nums[right] > nums[left - 1]) {
          break
        }
      }
      // 把找到的数跟降序集合左边数换位置
      swap(nums, left - 1, right);
      // 取降序集合右边数为起点，结束点还是数组末尾，接下来将这一段数组按照升序排列，最终得到的数字才是正好比当前组合数字稍大的数
      start = left;
    }

    let sum = start + end;
    for (let i = start; i <= sum / 2; i++) {
      swap(nums, i, sum - i)
    }

    function swap(list, i, j) {
      let tem = list[i];
      list[i] = list[j];
      list[j] = tem;
    }
  }

</script>
</body>
</html>