<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>2020/03/06 继承</title>
</head>
<body>

<script type="text/javascript">

  /**
   * 1.继承后的构造函数的原型添加方法一定要放在替换原型的语句之后
   * 2.继承后，不要用字面量的方式给原型添加方法或属性，这样会导致原型被重写，原型链被切断。
   * */


  function SuperType() {
    this.property = true;
  }

  SuperType.prototype.getSuperValue = function () {
    return this.property
  };

  function OubType() {
    this.oubproperty = false;
  }

  OubType.prototype = new SuperType();//OubType的原型被重写为SuperType的实例，既继承了SuperType

  OubType.prototype.getOubValue = function () {
    return this.oubproperty
  };

  var instance = new OubType();//创建了OubType的实例
  /**
   * instance实例调用了getSuperValue方法，根据JS相关理论
   * 在instance中没找到，就会去他的构造函数OubType中去找
   * OubType中也没有这个方法，就去他的原型中找，OubType的原型被重写为了SuperType的实例
   * 在SuperType中也没有这个方法，于是去SuperType的原型中去找，找到了这个方法，最终返回property=true
   * 完成了变相的继承。
   * */
  console.log(instance.getSuperValue());

  //P167借用构造函数
  function Parent1(name) {
    this.name = name;
  }

  function Son1() {
    Parent1.call(this, "张三");//通过call或apply方法，在创建实例时调用Parent1构造函数。既继承了Parent1
    this.age = 18;//在调用构造函数后在添加子类型定义的属性
  }

  let instance1 = new Son1();
  // console.log(instance1.name)
  // console.log(instance1.age)
  // console.log(instance1)

  //组合继承，结合原型链和借用构造函数
  function Parent2(name) {
    this.name = name;
    this.colors = ['green', 'red', 'white']
  }

  Parent2.prototype.sayName = function () {//在原型上定义方法
    console.log(this.name)
  };

  function Son2(name, age) {
    Parent2.call(this, name);//继承属性

    this.age = age;//自定义子类型的属性
  }

  Son2.prototype = new Parent2();
  Son2.prototype.constructor = Son2;
  Son2.prototype.sayAge = function () {//子类型的原型上定义方法，获取子类型自定义的属性
    console.log(this.age)
  }

  let instance2 = new Son2("李四", 28);
  instance2.colors.push("black")
  instance2.sayName();
  console.log(instance2)

  let instance3 = new Son2("王五", 41);
  console.log(instance3)

</script>
</body>
</html>